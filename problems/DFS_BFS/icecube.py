## Question ##

# N*M 크기의 얼음틀에 구멍이 뚫려있는 부분이 0, 칸막이가 1이라고 할때, 구멍으로 뚫려있는부분끼리 상하좌우로 붇어있는경우 서로 연결되어있는거로 간주할때. 생성되는 총 아이스크림의 갯수 구하라

# INPUT = 
# 15 14
# 00000111100000
# 11111101111110
# 11011101101110
# 11011101100000
# 11011111111111
# 11011111111100
# 11000000011111
# 01111111111111
# 00000000011111
# 01111111111000
# 00011111111000
# 00000001111000
# 11111111110011
# 11100011111111
# 11100011111111
# ANSWER = 8


## My Answer


## Solution 1
n, m = map(int, input().split())
graph = []
for i in range(n):
    graph.append(list(map(int, input()))) # 데이터 띄어쓰기없이 받아줌.


def dfs(x, y): # (x,y)좌표의 칸을 받음.
    if x <= -1 or x >= n or y <= -1 or y >= m: # 범위밖의 입력값을 받으면 즉시 종료.
        return False

    if graph[x][y] == 0: # 그 좌표에 값이 구멍이난(아직채워지지 않은곳) 이라면
        graph[x][y] = 1 # 채워졌다고(방문했다고, =1) 처리를 해줌
        dfs(x - 1, y) # 좌표의 왼쪽도 0인지확인후 채워줌 - 재귀함수.
        dfs(x + 1, y) # 오른쪽도
        dfs(x, y - 1) # 아래쪽도
        dfs(x, y + 1) # 위쪽도
        return True # 모든방향확인후 다끝났다면, 참을 1번 리턴

    return False # 좌표 하나와 그주변4곳을 확인후, 즉시 종료


result = 0 # 결과값 숫자이다.
for i in range(n): # N * M 에서 
    for j in range(m):
        if dfs(i, j) == True: # 만약에 트루 즉 한번의 dfs가 끝이난결과가있으면
            result += 1 # 결과값 1씩증가.

print(result)


## Notes ##
# 1. 생각보다 어렵지 않음
# 2. DFS는 재귀함수. 대신언제 어떤식으로 할지. (방문/미방문을 찾을때 사용!!)